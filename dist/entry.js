!function(t){var r={};function a(n){if(r[n])return r[n].exports;var e=r[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.m=t,a.c=r,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(e,n){if(1&n&&(e=a(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)a.d(t,r,function(n){return e[n]}.bind(null,r));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="",a(a.s="./src/index.js")}({"./src/compiler/helpers.js":
/*!*********************************!*\
  !*** ./src/compiler/helpers.js ***!
  \*********************************/
/*! exports provided: getAndRemoveAttr */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAndRemoveAttr", function() { return getAndRemoveAttr; });\nfunction getAndRemoveAttr(el\n/*: ASTElement*/\n, name\n/*: string*/\n)\n/*: ?string*/\n{\n  let val;\n\n  if ((val = el.attrsMap[name]) != null) {\n    const list = el.attrsList;\n\n    for (let i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  return val;\n}\n\n//# sourceURL=webpack:///./src/compiler/helpers.js?')},"./src/compiler/index.js":
/*!*******************************!*\
  !*** ./src/compiler/index.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _parser_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser/parse */ "./src/compiler/parser/parse.js");\n// 编译HTML模板\n// 找到对应的属性值然后传给Watch方法\n// import Watcher from \'../observer/Watcher\'\n // const loScrateReg = () => new RegExp(/\\{\\{(.*)\\}\\}/g)\n\nclass Compiler {\n  constructor(template) {\n    this.template = template;\n    this.ast = this.compile();\n  }\n\n  getAST() {\n    console.log(\'=============AST tree============\');\n    console.dir(this.ast);\n  }\n\n  compile() {\n    return Object(_parser_parse__WEBPACK_IMPORTED_MODULE_0__["default"])(this.template);\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (Compiler);\n\n//# sourceURL=webpack:///./src/compiler/index.js?')},"./src/compiler/parser/parse.js":
/*!**************************************!*\
  !*** ./src/compiler/parser/parse.js ***!
  \**************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parse; });\n/* harmony import */ var _parseHtml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseHtml */ "./src/compiler/parser/parseHtml.js");\n/* harmony import */ var _parseText__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseText */ "./src/compiler/parser/parseText.js");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers */ "./src/compiler/helpers.js");\n\n\n\nconst forReg = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nconst forIteratorReg = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\nfunction parse(template\n/*:string*/\n)\n/*: ASTElement | void*/\n{\n  // tag栈\n  const stack = []; // AST树根节点\n\n  let root, curParent;\n  Object(_parseHtml__WEBPACK_IMPORTED_MODULE_0__["default"])(template, {\n    start(tag) {\n      const {\n        tagName,\n        attrsList,\n        unary\n      } = tag;\n      const element\n      /*: ASTElement*/\n      = {\n        type: 1,\n        tag: tagName,\n        attrsList,\n        attrsMap: makeAttrsMap(attrsList),\n        //{ [key: string]: string | null };\n        parent: curParent || \'root\',\n        children: [] // 处理v-xx指令\n\n      };\n      processFor(element); // 处理树结构\n\n      if (!root) {\n        root = element;\n      }\n\n      if (curParent) {\n        curParent.children.push(element);\n      } // 如果不是自闭合标签，入栈,修改父节点\n\n\n      if (unary) {\n        curParent = element;\n        stack.push(element);\n      }\n    },\n\n    end() {\n      // 修改curParrent指向\n      if (stack.pop()) {\n        curParent = stack[stack.length - 1];\n      }\n    },\n\n    handleContent(content) {\n      if (!curParent) {\n        return;\n      }\n\n      let exp;\n\n      if (content && (exp = Object(_parseText__WEBPACK_IMPORTED_MODULE_1__["default"])(content))) {\n        const expNode\n        /*: ASTExpression*/\n        = {\n          type: 2,\n          expression: exp,\n          text: content\n        };\n        curParent.children.push(expNode);\n      } else {\n        const textNode\n        /*: ASTText*/\n        = {\n          type: 3,\n          text: content\n        };\n        curParent.children.push(textNode);\n      }\n    },\n\n    warn(msg) {\n      console.log(msg);\n    }\n\n  });\n  return root;\n}\n\nfunction makeAttrsMap(attrs\n/*: Array<Object>*/\n)\n/*: Object*/\n{\n  const map = {};\n\n  for (let i = 0, l = attrs.length; i < l; i++) {\n    if (map[attrs[i].name]) {\n      console.log(\'duplicate attribute: \' + attrs[i].name);\n    }\n\n    map[attrs[i].name] = attrs[i].value;\n  }\n\n  return map;\n} // 处理v-for\n\n\nfunction processFor(el) {\n  let exp;\n\n  if (exp = Object(_helpers__WEBPACK_IMPORTED_MODULE_2__["getAndRemoveAttr"])(el, \'v-for\')) {\n    const inMatch = exp.match(forReg);\n\n    if (!inMatch) {\n      console.log(`Invalid v-for expression: ${exp}`);\n      return;\n    }\n\n    el.for = inMatch[2].trim();\n    const alias = inMatch[1].trim();\n    const iteratorMatch = alias.match(forIteratorReg);\n\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/compiler/parser/parse.js?')},"./src/compiler/parser/parseHtml.js":
/*!******************************************!*\
  !*** ./src/compiler/parser/parseHtml.js ***!
  \******************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return parseHtml; });\nconst tagNameReg = '([a-zA-Z_][\\\\w\\\\-\\\\.]*)';\nconst startTagOpenReg = new RegExp('^<' + tagNameReg);\nconst startTagCloseReg = /^\\s*(\\/?)>/;\nconst endTagReg = new RegExp('^<\\\\/' + tagNameReg + '\\\\s*>');\nconst attrReg = /^\\s+([\\w_-]+)(?:=[\"']([\\w\\s\\.\\(\\),]+)[\"'])?/;\nconst doctypeReg = /^<!DOCTYPE [^>]+>/i;\nconst commentReg = /^\x3c!--/;\nfunction parseHtml(template, options) {\n  let html = template,\n      index = 0; // 匹配结束标签\n\n  const stack = [];\n\n  while (html = html.trim()) {\n    if (~(index = html.indexOf('<'))) {\n      if (index > 0) {\n        options.handleContent(html.slice(0, index));\n        advance(index);\n      } // comment match\n\n\n      const commentMatch = html.match(commentReg);\n\n      if (commentMatch) {\n        const commentEnd = html.indexOf('--\x3e');\n        advance(commentEnd + 3);\n        continue;\n      } // doctype match\n\n\n      const doctypeMatch = html.match(doctypeReg);\n\n      if (doctypeMatch) {\n        advance(doctypeMatch[0].length);\n        continue;\n      } // tag match\n\n\n      const endTagMatch = html.match(endTagReg);\n\n      if (endTagMatch) {\n        handleEndTag(endTagMatch);\n        continue;\n      }\n\n      const startTag = parseStartTag();\n\n      if (startTag) {\n        handleStartTag(startTag);\n        continue;\n      }\n    } else if (stack.length) {\n      options.handleContent(html);\n      html = '';\n    } else {\n      options.warn('tag not match');\n      return;\n    }\n  }\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    const match = html.match(startTagOpenReg);\n\n    if (match) {\n      advance(match[0].length);\n      const tag = {\n        tagName: match[1],\n        attrsList: []\n      };\n      let tagCloseMatch, attrMatch;\n\n      while (!(tagCloseMatch = html.match(startTagCloseReg)) && (attrMatch = html.match(attrReg))) {\n        if (attrMatch) {\n          tag.attrsList.push({\n            name: attrMatch[1],\n            value: attrMatch[2] || true\n          });\n          advance(attrMatch[0].length);\n        }\n      }\n\n      if (tagCloseMatch) {\n        tag.unary = !tagCloseMatch[1];\n        advance(tagCloseMatch[0].length);\n      }\n\n      return tag;\n    }\n  }\n\n  function handleStartTag(tag) {\n    if (tag.unary) {\n      stack.push(tag.tagName);\n    }\n\n    if (options.start) {\n      options.start(tag);\n    }\n  }\n\n  function handleEndTag(endMatch) {\n    const startTagName = stack.pop() || '';\n\n    if (startTagName !== endMatch[1]) {\n      options.warn('tag is not closed correctly');\n      html = '';\n    } else {\n      if (options.end) {\n        options.end();\n      }\n\n      advance(endMatch[0].length);\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/compiler/parser/parseHtml.js?")},"./src/compiler/parser/parseText.js":
/*!******************************************!*\
  !*** ./src/compiler/parser/parseText.js ***!
  \******************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return parseText; });\nconst dataExpReg = () => new RegExp(/\\{\\{((?:.|\\n)+?)\\}\\}/g);\n\nfunction parseText(text\n/*: string*/\n)\n/*: ?string*/\n{\n  const result\n  /*: Array<string>*/\n  = [];\n  const dataReg = dataExpReg();\n\n  if (!dataReg.test(text)) {\n    return;\n  }\n\n  let lastIndex = 0;\n  let match;\n  dataReg.lastIndex = 0;\n\n  while (match = dataReg.exec(text)) {\n    const {\n      index\n    } = match;\n\n    if (index > lastIndex) {\n      result.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n\n    result.push(`_s(${match[1].trim()})`);\n    lastIndex = index + match[0].length;\n  }\n\n  if (lastIndex < text.length) {\n    result.push(JSON.stringify(text.slice(lastIndex)));\n  }\n\n  return result.join('+');\n}\n\n//# sourceURL=webpack:///./src/compiler/parser/parseText.js?")},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compiler */ "./src/compiler/index.js");\n\ndocument.getElementById(\'input\').value = \'<div name="coco"><span>{{data}}</span><input type="text"/>hello {{name}}</div>\';\nlet parsebtn = document.getElementById(\'parse\');\nparsebtn.addEventListener("click", function () {\n  const tpl = document.getElementById(\'input\').value;\n  console.log(tpl);\n  const compiler = new _compiler__WEBPACK_IMPORTED_MODULE_0__["default"](tpl);\n  compiler.getAST();\n});\n\n//# sourceURL=webpack:///./src/index.js?')}});